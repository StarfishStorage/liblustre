======================================
liblustre: A (not yet LGPL) lustre API
======================================

This is work in progress. NOT ALL FILES ARE UNDER LGPL YET.

See https://jira.hpdd.intel.com/browse/LU-5969 for the rationale.

Organization
------------

The directory structure is as follow::

  * include/lustre/: exported headers API. They will be installed in
    /usr/include/lustre

  * lib/: the library source code.

  * man/: the man pages. These are written in ReST format and converted
    to nroff by rst2man from python-docutils.

  * tests: test programs for the library. They are run with make
    check.

The new header to include by applications is <lustre/lustre.h>. No
other file need to be included. <lustre/lustre.h> will itself include
<lustre/lustre_user.h>, but that file cannot be included directly.

The library itself includes <lustre/lustre.h>, but also
"lustre_internal.h" which contains various definitions and helpers
that are needed for the library but need not be exported, such as
private structures, ioctls definitions, ...

No application should communicate directly with lustre, through ioctls
for instance. Instead simple functions must be provided.

Only the functions that are part of the API must appear in
liblustre.map.


This version adds the structure lustre_fs_h which represents a Lustre
filesystem. An application has to open the filesystem first with
lustre_open_fs, and an opaque handle is returned. This handle is then
used by functions like llapi_fid2path(), which have been modified to
require that handle. This avoids opening the filesystem for many
operations.

An updated API
--------------

The current liblustreapi has some shortcomings. For instance many
function will search for the mountpoint of a lustre filesystem, open
it, issue an ioctl, then close the it. This is not always
necessary. For instanmce when using the copytool, we already know
everything we need about the filesystem, thus we should be able to
open it once.

struct lustre_fs_h
~~~~~~~~~~~~~~~~~~

This is a new structure meant to keep the information os an existing
filesystem (mountpoint, name, ...) so the information doesn't have to
be retrieved more than once. Thus we open and close a filesystem
with::

  void lustre_close_fs(struct lustre_fs_h *lfsh)
  int lustre_open_fs(const char *mount_path, struct lustre_fs_h **lfsh)

lfsh is an opaque handle that can then be passed to various functions::

  int llapi_fid2path(const struct lustre_fs_h *lfsh, const struct
  lu_fid *fid, char *path, int path_len, long long *recno, int
  *linkno)

  int llapi_open_by_fid(const struct lustre_fs_h *lfsh, const
  lustre_fid *fid, int open_flags)

  int llapi_hsm_copytool_register(const struct lustre_fs_h *lfsh,
  struct hsm_copytool_private **priv, int archive_count, int
  *archives, int rfd_flags)

posix copytool
~~~~~~~~~~~~~~

As an example, and to validate this solution, the posix copytool has
been ported to this new API, in the tests/ directory.

Here's an strace difference for an archiving operation. Similar traces
are not shown.

copytool based on liblustreapi::

    ....
    [pid 14694] open("/etc/mtab", O_RDONLY) = 8
    [pid 14694] fstat(8, {st_mode=S_IFREG|0644, st_size=627, ...}) = 0
    [pid 14694] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa1bbe14000
    [pid 14694] read(8, <unfinished ...>
    [pid 14694] <... read resumed> "/dev/mapper/vg_c65l251intel-lv_r"..., 4096) = 627
    [pid 14694] read(8, "", 4096) = 0
    [pid 14694] close(8) = 0
    [pid 14694] munmap(0x7fa1bbe14000, 4096) = 0
    [pid 14694] open("/mnt/lustre", O_RDONLY|O_NONBLOCK|O_DIRECTORY) = 8
    [pid 14694] ioctl(8, 0xffffffffc0086696, 0x7fa1b40008c0) = 0
    [pid 14694] close(8) = 0
    ....

copytool under liblustre::

    ...
    [pid 14756] ioctl(4, 0xc0086696, 0x7ffdf80008c0) = 0
    ...

The restore operation shows similar savings.

Future direction
~~~~~~~~~~~~~~~~

Robinhood should benefit a lot too from this updated API, since a lot
of its interaction with Lustre is similar to the copytool.

TODO
----

* All exported API functions should be documented in lustre.h, not in
  the C file. Format should be the same as lustre (doxygen) and
  conformity enforced during build.
* All exported API functions should have at least a small test.
* Fix all the "TODO"s
* Add a man page for every API.
* Provide an rpm specfile
* check each mention of lustreapi and fix
* do something with llapi_hsm_log_error; it doesn't fit.

Changes from liblustreapi
-------------------------

Some function have disappeared and other have been renamed. This
section should help porting.

* LPU64 is gone. Use "%llu". Cast if necessary.
* LPX64 is gone. Use "%#llx". Cast if necessary.
* LPX64i is gone. Use "%llx". Cast if necessary.
* llapi_file_open_pool and llapi_file_open_param are gone. Use
  llapi_layout_file_open or llapi_layout_file_openat. Careful with the
  return code. The former function returned negative errno, while the
  new one return -1 and sets errno.
* llapi_file_open_param is gone. Use llapi_file_open.
* llapi_create_volatile_idx is gone, and is replaced with
  llapi_create_volatile_by_fid and a layout parameters.
* llapi_chomp_string is not exported anymore.

logging
~~~~~~~

liblustre doesn't provide an API to log messages. It is the job of the
application to emit these logs. By default no logs are evaluated. To
retrieve the log messages, the application has to set a callback with
llapi_msg_callback_set() and set a log level with
llapi_msg_set_level(). When the callback is called, the application
can then emit the messages if it wishes. lhsmtool_posix.c has been
modified to use that interface. The posix copytool will output all its
messages on stdout.
